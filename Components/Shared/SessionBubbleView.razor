<!--/* In the name of God, the Merciful, the Compassionate */-->
@using SqlHealthAssessment.Data.Models

<div class="bubble-view-container">
    @if (Sessions == null || Sessions.Count == 0)
    {
        <div class="chart-empty" style="padding: 60px;">No sessions to display</div>
    }
    else
    {
        <svg width="100%" height="@SvgHeight" viewBox="0 0 @SvgWidth @SvgHeight"
             xmlns="http://www.w3.org/2000/svg" class="bubble-svg">

            @* Background gradient *@
            <defs>
                @* Modern sleek gradients *@
                <radialGradient id="bubbleGradNormal" cx="35%" cy="25%" r="70%">
                    <stop offset="0%" stop-color="#64b5f6" />
                    <stop offset="50%" stop-color="#1976d2" />
                    <stop offset="100%" stop-color="#0d47a1" />
                </radialGradient>
                <radialGradient id="bubbleGradBlocked" cx="35%" cy="25%" r="70%">
                    <stop offset="0%" stop-color="#ef5350" />
                    <stop offset="50%" stop-color="#c62828" />
                    <stop offset="100%" stop-color="#b71c1c" />
                </radialGradient>
                <radialGradient id="bubbleGradIdle" cx="35%" cy="25%" r="70%">
                    <stop offset="0%" stop-color="#81c784" />
                    <stop offset="50%" stop-color="#388e3c" />
                    <stop offset="100%" stop-color="#1b5e20" />
                </radialGradient>
                @* Glow effect for selected *@
                <filter id="glowSelected" x="-50%" y="-50%" width="200%" height="200%">
                    <feGaussianBlur stdDeviation="6" result="coloredBlur" />
                    <feMerge>
                        <feMergeNode in="coloredBlur" />
                        <feMergeNode in="SourceGraphic" />
                    </feMerge>
                </filter>
                @* Drop shadow *@
                <filter id="bubbleShadow" x="-20%" y="-20%" width="140%" height="140%">
                    <feDropShadow dx="0" dy="4" stdDeviation="6" flood-color="#000" flood-opacity="0.35" />
                </filter>
                @* Inner glow for 3D effect *@
                <radialGradient id="innerGlow" cx="50%" cy="50%" r="50%">
                    <stop offset="0%" stop-color="#fff" stop-opacity="0.3" />
                    <stop offset="100%" stop-color="#fff" stop-opacity="0" />
                </radialGradient>
            </defs>

            @* Blocking lines *@
            @foreach (var session in Sessions.Where(s => s.IsBlocked))
            {
                var blocker = Sessions.FirstOrDefault(s => s.SPID == session.BlockingSessionId);
                if (blocker != null)
                {
                    var blockedPos = GetPosition(session.SPID);
                    var blockerPos = GetPosition(blocker.SPID);
                    <line x1="@blockerPos.x" y1="@blockerPos.y"
                          x2="@blockedPos.x" y2="@blockedPos.y"
                          class="blocking-line" />
                }
            }

            @* Bubbles with animation *@
            @foreach (var session in Sessions)
            {
                var pos = GetPosition(session.SPID);
                var radius = GetRadius(session);
                var fill = GetFill(session);
                var strokeColor = GetStrokeColor(session);
                var strokeWidth = GetStrokeWidth(session);
                var isSelected = SelectedSpid == session.SPID;

                <g class="session-bubble @(isSelected ? "selected" : "") @(session.IsActive ? "active" : "")"
                   @onclick="() => OnBubbleClicked(session)"
                   style="cursor: pointer; transition: transform 0.3s ease-out;">

                    @* Main circle with shadow *@
                    <circle cx="@pos.x" cy="@pos.y" r="@radius"
                            fill="@fill" 
                            stroke="@strokeColor" stroke-width="@strokeWidth"
                            filter="@(isSelected ? "url(#glowSelected)" : "url(#bubbleShadow)")"
                            class="bubble-circle" />

                    @* Inner highlight *@
                    <circle cx="@(pos.x - radius * 0.25)" cy="@(pos.y - radius * 0.25)" 
                            r="@(radius * 0.4)" 
                            fill="url(#innerGlow)" 
                            class="bubble-highlight" />

                    @* SPID label *@
                    <text x="@pos.x" y="@(pos.y + 1)"
                          text-anchor="middle" dominant-baseline="central"
                          fill="white" font-size="@GetFontSize(radius)"
                          font-weight="600" font-family="Segoe UI, sans-serif"
                          pointer-events="none"
                          class="bubble-label">
                        @session.SPID
                    </text>

                    @* Activity indicator *@
                    @if (session.ActivityScore > 100)
                    {
                        <circle cx="@(pos.x + radius * 0.6)" cy="@(pos.y - radius * 0.6)" 
                                r="4" fill="#4caf50" class="activity-dot" />
                    }
                </g>
            }
        </svg>
    }
</div>

@code {
    [Parameter] public List<SessionInfo>? Sessions { get; set; }
    [Parameter] public EventCallback<SessionInfo> OnSessionClicked { get; set; }
    [Parameter] public int? SelectedSpid { get; set; }

    private int SvgWidth = 900;
    private int SvgHeight = 500;
    private const double GoldenAngle = 2.39996322972865; // 137.508 degrees in radians

    // Cache positions so blocking lines can look up coordinates
    private Dictionary<int, (double x, double y)> _positionCache = new();
    private Random _random = new();
    private int _refreshCount = 0;

    protected override void OnParametersSet()
    {
        // Rebuild position cache whenever sessions change
        _positionCache.Clear();
        if (Sessions == null || Sessions.Count == 0) return;

        // Increment refresh count to add subtle movement
        _refreshCount++;
        
        // Sort: biggest (most active) sessions in the center
        var sorted = Sessions.OrderByDescending(s => s.ActivityScore).ToList();
        var centerX = SvgWidth / 2.0;
        var centerY = SvgHeight / 2.0;

        // Spiral placement using golden angle
        double angle = 0;
        double spiralSpacing = 3.5;

        for (int i = 0; i < sorted.Count; i++)
        {
            var session = sorted[i];
            var radius = GetRadius(session);

            if (i == 0)
            {
                // First (most active) session goes dead center
                _positionCache[session.SPID] = (centerX, centerY);
            }
            else
            {
                // Spiral out from center
                var dist = spiralSpacing * Math.Sqrt(i) * (radius + 10);
                var x = centerX + dist * Math.Cos(angle);
                var y = centerY + dist * Math.Sin(angle);

                // Add subtle random offset for movement effect (only 2-3 pixels)
                var offsetSeed = (session.SPID * 7 + _refreshCount) % 20 - 10;
                x += offsetSeed * 0.3;
                y += (offsetSeed * 13) % 17 * 0.2;

                // Clamp to SVG bounds with padding
                var pad = radius + 5;
                x = Math.Clamp(x, pad, SvgWidth - pad);
                y = Math.Clamp(y, pad, SvgHeight - pad);

                _positionCache[session.SPID] = (x, y);
            }
            angle += GoldenAngle;
        }
    }

    private (double x, double y) GetPosition(int spid)
    {
        return _positionCache.TryGetValue(spid, out var pos) ? pos : (SvgWidth / 2.0, SvgHeight / 2.0);
    }

    private double GetRadius(SessionInfo session)
    {
        var activity = session.ActivityScore;
        // Log-scale: minimum 14px radius, maximum 45px
        if (activity <= 0) return 14;
        return Math.Clamp(14 + Math.Log10(activity + 1) * 6, 14, 45);
    }

    private string GetFill(SessionInfo session)
    {
        if (session.IsBlocked || session.IsIdleInTransaction)
            return "url(#bubbleGradBlocked)";
        if (session.IsSleeping && !session.IsActive)
            return "url(#bubbleGradIdle)";
        return "url(#bubbleGradNormal)";
    }

    private string GetStrokeColor(SessionInfo session)
    {
        if (session.IsIdleInTransaction)
            return "#ff0000"; // Dangerous: idle in transaction
        if (session.OpenTransactionCount > 0)
            return "#ffd700"; // In transaction (gold)
        return "none";
    }

    private int GetStrokeWidth(SessionInfo session)
    {
        if (session.IsIdleInTransaction)
            return 4; // Thick red border = dangerous
        if (session.OpenTransactionCount > 0)
            return 2; // Thin gold border = active in txn
        return 0;
    }

    private int GetFontSize(double radius)
    {
        if (radius >= 35) return 14;
        if (radius >= 25) return 12;
        if (radius >= 18) return 10;
        return 8;
    }

    private async Task OnBubbleClicked(SessionInfo session)
    {
        await OnSessionClicked.InvokeAsync(session);
    }
}
