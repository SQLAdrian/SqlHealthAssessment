<!--/* In the name of God, the Merciful, the Compassionate */-->
@using System.Data

@using System.Collections.Concurrent
@using SqlHealthAssessment.Data
@using SqlHealthAssessment.Data.Caching
@using SqlHealthAssessment.Data.Models
@inject DashboardConfigService ConfigService
@inject DashboardDataService DataService
@inject QueryExecutor QueryExecutor
@inject CachingQueryExecutor CachingExecutor
@inject AutoRefreshService RefreshService
@inject UserSettingsService UserSettings
@inject ServerConnectionManager ConnectionManager
@inject GlobalInstanceSelector InstanceSelector
@inject QueryThrottleService QueryThrottle
@implements IDisposable


@if (ConnectionManager.CurrentServer != null || Instances.Length > 0)
{
    <div class="server-context-header">
        <span class="server-context-icon">üñ•Ô∏è</span>
        <span class="server-context-label">Connected to:</span>
        @if (ConnectionManager.CurrentServer != null)
        {
            <span class="server-context-name">@ConnectionManager.CurrentServer.ServerNames</span>
            <span class="server-context-db">(@ConnectionManager.CurrentServer.Database)</span>
        }
        <span class="server-context-label" style="margin-left: 16px;">Instance:</span>
        <select class="toolbar-select" style="margin-left: 4px;" @onchange="OnInstanceChanged">
            @if (Dashboard?.ShowAllOption ?? false)
            {
                <option value="ALL">All Instances</option>
            }
            @foreach (var instance in Instances)
            {
                <option value="@instance" selected="@(SelectedInstance == instance)">@instance</option>
            }
        </select>
    </div>
}

<DashboardToolbar @bind-TimeRangeMinutes="TimeRangeMinutes"
                  @bind-AutoRefresh="AutoRefresh"
                  @bind-TimezoneOffsetHours="TimezoneOffsetHours"
                  OnRefreshRequested="OnManualRefresh"
                  OnServerChanged="OnServerConnectionChanged" />

<div class="dashboard-content">

    @if (!string.IsNullOrEmpty(ErrorMessage))
    {
        <div class="chart-empty" style="color: #f44336; background: #2a1a1a; border: 1px solid #f44336; padding: 12px; margin: 8px; border-radius: 4px;">
            @ErrorMessage
        </div>
    }

    @* Show panel errors *@
    @if (_panelErrors.Any())
    {
        <div class="chart-empty" style="color: #ff9800; background: #2a2000; border: 1px solid #ff9800; padding: 12px; margin: 8px; border-radius: 4px;">
            <strong>&#9888; Data Load Warnings:</strong>
            <ul style="margin: 8px 0 0 0; padding-left: 20px;">
                @foreach (var err in _panelErrors)
                {
                    <li>@err.Key: @err.Value</li>
                }
            </ul>
        </div>
    }

    @if (RequiresSqlWatch && !CurrentServerHasSqlWatch)
    {
        <div class="sqlwatch-required-banner">
            <span class="sqlwatch-required-icon">‚ö†Ô∏è</span>
            <div>
                <strong>SQLWATCH is not installed on this server</strong>
                <div class="sqlwatch-required-detail">
                    This dashboard requires the SQLWATCH database. Please install SQLWATCH on the
                    selected server, or switch to a server that already has SQLWATCH installed.
                </div>
            </div>
        </div>
    }

    @if (IsLoading && (CurrentServerHasSqlWatch || !RequiresSqlWatch))
    {
        <div class="chart-empty">Loading data...</div>
    }
    else if (Dashboard != null && (CurrentServerHasSqlWatch || !RequiresSqlWatch))
    {
        @* Stat cards section *@
        @if (_statPanelsCache?.Any() == true)
        {
            <div class="stat-grid">
                @foreach (var panel in _statPanelsCache)
                {
                    if (panel.PanelType == "CheckStatus" && _checkResults.TryGetValue(panel.Id, out var checks))
                    {
                        <DynamicPanel Panel="panel" CheckData="checks" TimezoneOffsetHours="@TimezoneOffsetHours" />
                    }
                    else if ((panel.PanelType == "StatCard" || panel.PanelType == "DeltaStatCard") && _statResults.TryGetValue(panel.Id, out var stat))
                    {
                        <DynamicPanel Panel="panel" StatData="stat" TimezoneOffsetHours="@TimezoneOffsetHours" />
                    }
                }
            </div>
        }

        @* Details section *@
        @if (_detailsPanelsCache?.Any() == true)
        {
            <div class="details-section">
                @foreach (var panel in _detailsPanelsCache)
                {
                    if (_gridResults.TryGetValue(panel.Id, out var grid))
                    {
                        <DynamicPanel Panel="panel" GridData="grid" TimezoneOffsetHours="@TimezoneOffsetHours" />
                    }
                }
            </div>
        }

        @* Bar gauge panels *@
        @if (_gaugePanelsCache?.Any() == true)
        {
            @foreach (var panel in _gaugePanelsCache)
            {
                if (_barGaugeResults.TryGetValue(panel.Id, out var gaugeData))
                {
                    <div class="chart-grid-item" style="position: relative;">
                        <button class="panel-maximize-btn" @onclick="() => MaximizePanel(panel)" title="Maximize">‚õ∂</button>
                        <DynamicPanel Panel="panel" BarGaugeData="gaugeData" TimezoneOffsetHours="@TimezoneOffsetHours" />
                    </div>
                }
            }
        }

        @* Maximized panel overlay *@
        @if (_maximizedPanel != null)
        {
            <div class="panel-maximize-overlay" @onclick="RestorePanel">
                <div class="panel-maximize-content" @onclick:stopPropagation>
                    <div class="panel-maximize-header">
                        <span class="panel-maximize-title">@_maximizedPanel.Title</span>
                        <button class="panel-maximize-close" @onclick="RestorePanel" title="Restore">‚úï</button>
                    </div>
                    <div class="panel-maximize-body">
                        <DynamicPanel Panel="@_maximizedPanelExpanded"
                                      TimeSeriesData="@(_timeSeriesResults.TryGetValue(_maximizedPanel.Id, out var mts) ? mts : null)"
                                      GridData="@(_gridResults.TryGetValue(_maximizedPanel.Id, out var mgd) ? mgd : null)"
                                      BarGaugeData="@(_barGaugeResults.TryGetValue(_maximizedPanel.Id, out var mbg) ? mbg : null)"
                                      TimezoneOffsetHours="@TimezoneOffsetHours" />
                    </div>
                </div>
            </div>
        }

        @* Chart grid - 2 column layout *@
        @if (_chartPanelsCache?.Any() == true)
        {
            <div class="chart-grid">
                @foreach (var panel in _chartPanelsCache)
                {
                    @if (panel.Layout.SpanColumns)
                    {
                        <div class="chart-grid-full chart-grid-item">
                            <button class="panel-maximize-btn" @onclick="() => MaximizePanel(panel)" title="Maximize">‚õ∂</button>
                            @RenderChartOrGrid(panel)
                        </div>
                    }
                    else
                    {
                        <div class="chart-grid-item">
                            <button class="panel-maximize-btn" @onclick="() => MaximizePanel(panel)" title="Maximize">‚õ∂</button>
                            @RenderChartOrGrid(panel)
                        </div>
                    }
                }
            </div>
        }
    }
</div>

@code {
    [Parameter] public string DashboardId { get; set; } = "";

    private DashboardDefinition? Dashboard;
    private string SelectedInstance = "";
    private string[] Instances = Array.Empty<string>();
    private int TimeRangeMinutes = 60;
    private double TimezoneOffsetHours = 0;
    private bool AutoRefresh = true;
    private bool IsLoading = true;
    private string? ErrorMessage;

    // Data results keyed by panel ID
    private ConcurrentDictionary<string, List<TimeSeriesPoint>> _timeSeriesResults = new();
    private ConcurrentDictionary<string, StatValue> _statResults = new();
    private ConcurrentDictionary<string, List<StatValue>> _barGaugeResults = new();
    private ConcurrentDictionary<string, DataTable> _gridResults = new();
    private ConcurrentDictionary<string, List<CheckStatus>> _checkResults = new();
    private ConcurrentDictionary<string, string> _panelErrors = new();

    // Cached panel lists to avoid repeated LINQ on each render
    private List<PanelDefinition>? _enabledPanelsCache;
    private List<PanelDefinition>? _statPanelsCache;
    private List<PanelDefinition>? _detailsPanelsCache;
    private List<PanelDefinition>? _gaugePanelsCache;
    private List<PanelDefinition>? _chartPanelsCache;

    // Maximize state
    private PanelDefinition? _maximizedPanel;
    private PanelDefinition? _maximizedPanelExpanded;

    // Per-panel runtime TOP-rows values (keyed by panel ID)
    private Dictionary<string, int> _panelTopRows = new();

    // Maps SQLWATCH sql_instance names (@@SERVERNAME format) ‚Üí ServerConnection.Id.
    // Built during initialisation to bridge the gap between user-configured server names
    // (IP addresses, aliases) and the actual instance names SQLWATCH stores in its tables.
    private Dictionary<string, string> _sqlWatchInstanceToConnectionId = new(StringComparer.OrdinalIgnoreCase);

    // Tracks which connection IDs have a confirmed SQLWATCH installation (non-empty discovery).
    private readonly HashSet<string> _connectionsWithSqlWatch = new();

    // Dashboards that require SQLWATCH historical tables (the first 3 in dashboard-config.json).
    private static readonly HashSet<string> SqlWatchRequiredDashboards =
        new(StringComparer.OrdinalIgnoreCase) { "instance", "longqueries", "waitevents" };

    private bool RequiresSqlWatch => SqlWatchRequiredDashboards.Contains(DashboardId);
    private bool CurrentServerHasSqlWatch =>
        _connectionsWithSqlWatch.Contains(ConnectionManager.CurrentServer?.Id ?? "");

    private void MaximizePanel(PanelDefinition panel)
    {
        _maximizedPanel = panel;
        // Create a lightweight copy to avoid accidental mutation of original panel
        _maximizedPanelExpanded = new PanelDefinition
        {
            Id = panel.Id,
            Title = panel.Title,
            Description = panel.Description,
            Enabled = panel.Enabled,
            PanelType = panel.PanelType,
            ChartType = panel.ChartType,
            Height = panel.Height,
            RefreshIntervalSeconds = panel.RefreshIntervalSeconds,
            Layout = panel.Layout != null ? new PanelLayout { Column = panel.Layout.Column, Order = panel.Layout.Order, SpanColumns = panel.Layout.SpanColumns } : new PanelLayout(),
            Query = panel.Query != null ? new QueryPair { SqlServer = panel.Query.SqlServer, LiveQueries = panel.Query.LiveQueries } : new QueryPair(),
            StatUnit = panel.StatUnit,
            StatThresholdKey = panel.StatThresholdKey,
            BarGaugeThresholdKey = panel.BarGaugeThresholdKey,
            BarGaugeUnitSuffix = panel.BarGaugeUnitSuffix,
            ValueFormat = panel.ValueFormat,
            ColorThresholds = panel.ColorThresholds != null ? new List<ColorThresholdRule>(panel.ColorThresholds) : new List<ColorThresholdRule>(),
            DataGridIsClickable = panel.DataGridIsClickable,
            DataGridMaxRows = panel.DataGridMaxRows
        };
    }

    private void RestorePanel()
    {
        _maximizedPanel = null;
        _maximizedPanelExpanded = null;
    }

    private void RefreshPanelCaches()
    {
        _enabledPanelsCache = Dashboard?.Panels?.Where(p => p.Enabled).ToList() ?? new List<PanelDefinition>();
        _statPanelsCache = _enabledPanelsCache.Where(p => p.Layout.Column == 0 && (p.PanelType == "StatCard" || p.PanelType == "DeltaStatCard" || p.PanelType == "CheckStatus")).OrderBy(p => p.Layout.Order).ToList();
        _detailsPanelsCache = _enabledPanelsCache.Where(p => p.Layout.Column == 0 && p.PanelType == "TextCard").OrderBy(p => p.Layout.Order).ToList();
        _gaugePanelsCache = _enabledPanelsCache.Where(p => p.PanelType == "BarGauge").OrderBy(p => p.Layout.Order).ToList();
        _chartPanelsCache = _enabledPanelsCache.Where(p => p.PanelType == "TimeSeries" || p.PanelType == "DataGrid" || (p.PanelType != "StatCard" && p.PanelType != "CheckStatus" && p.PanelType != "BarGauge" && p.PanelType != "TextCard" && p.Layout.Column > 0)).OrderBy(p => p.Layout.Order).ToList();
    }

    protected override async Task OnInitializedAsync()
    {
        RefreshService.OnRefresh += OnAutoRefresh;
        ConfigService.OnConfigChanged += OnConfigChanged;
        InstanceSelector.OnInstanceChanged += OnGlobalInstanceChanged;

        TimezoneOffsetHours = UserSettings.GetTimezoneOffset();
        Dashboard = ConfigService.Config.Dashboards.FirstOrDefault(d => string.Equals(d.Id, DashboardId, StringComparison.OrdinalIgnoreCase));

        if (Dashboard == null)
        {
            System.Diagnostics.Debug.WriteLine($"[DynamicDashboard] Dashboard '{DashboardId}' not found. Available dashboards:");
            foreach (var d in ConfigService.Config.Dashboards)
            {
                System.Diagnostics.Debug.WriteLine($"[DynamicDashboard]   - {d.Id}");
            }
        }

        RefreshPanelCaches();

        var connections = ConnectionManager.GetConnections();
        var availableInstances = connections.SelectMany(c => c.GetServerList()).Distinct().ToList();
        Instances = availableInstances.ToArray();
        var initialInstance = InstanceSelector.SelectedInstance ?? (availableInstances.Any() ? availableInstances[0] : "");
        SelectedInstance = initialInstance;
        SetServerContext(initialInstance);

        // Discover actual SQLWATCH instance names ‚Äî they may differ from the user-configured
        // connection names (e.g. IP addresses vs @@SERVERNAME). Must run before first LoadData.
        await DiscoverAndUpdateInstancesAsync();

        await LoadData();
        if (AutoRefresh) RefreshService.Start();
    }

    private async void OnGlobalInstanceChanged(string instanceName)
    {
        SelectedInstance = instanceName;
        SetServerContext(instanceName);
        await InvokeAsync(async () =>
        {
            await LoadData();
            StateHasChanged();
        });
    }

    private async Task OnInstanceChanged(ChangeEventArgs e)
    {
        var instance = e.Value?.ToString() ?? "";
        SelectedInstance = instance;
        InstanceSelector.SetSelectedInstance(instance);
        SetServerContext(instance);
        await LoadData();
    }
    
    private void SetServerContext(string instanceName)
    {
        // Priority 1: SQLWATCH instance name ‚Üí connection ID (populated after discovery).
        if (_sqlWatchInstanceToConnectionId.TryGetValue(instanceName, out var connId))
        {
            ConnectionManager.SetCurrentServer(connId);
            return;
        }

        // Priority 2: user-configured server name inside a connection's server list.
        var connection = ConnectionManager.GetConnections()
            .FirstOrDefault(c => c.GetServerList().Contains(instanceName));

        // Priority 3: fall back to first available connection so queries don't break.
        connection ??= ConnectionManager.GetConnections().FirstOrDefault();
        ConnectionManager.SetCurrentServer(connection?.Id);
    }

    private DashboardFilter BuildFilter()
    {
        var now = DateTime.Now;
        string[] instances;

        if (SelectedInstance == "ALL" && _sqlWatchInstanceToConnectionId.Any())
            instances = _sqlWatchInstanceToConnectionId.Keys.ToArray();
        else
            instances = new[] { SelectedInstance };

        return new DashboardFilter
        {
            TimeFrom = now.AddMinutes(-TimeRangeMinutes),
            TimeTo = now,
            Instances = instances
        };
    }

    /// <summary>
    /// Builds the Instances dropdown by querying every enabled connection.
    ///
    /// Strategy per connection:
    ///   HasSqlWatch=true  + SQLWATCH found  ‚Üí use discovered @@SERVERNAME names (so @SqlInstance
    ///                                         filters match what SQLWATCH stored).  Connection is
    ///                                         added to _connectionsWithSqlWatch.
    ///   HasSqlWatch=true  + SQLWATCH absent ‚Üí fall back to the user-configured server names so
    ///                                         the entry still appears in the dropdown (banner shown).
    ///   HasSqlWatch=false                   ‚Üí always use user-configured names (master-context
    ///                                         dashboards like Live Monitor work fine without SQLWATCH).
    ///
    /// All servers always appear in every dashboard's dropdown.  The SQLWATCH-required banner
    /// handles the "wrong server" case instead of hiding the server from the list.
    /// </summary>
    private async Task DiscoverAndUpdateInstancesAsync()
    {
        var allConnections = ConnectionManager.GetEnabledConnections();
        if (allConnections.Count == 0) return;

        var allInstances = new List<string>();

        foreach (var conn in allConnections)
        {
            if (conn.HasSqlWatch)
            {
                // Attempt live discovery so @SqlInstance filters match @@SERVERNAME.
                try
                {
                    ConnectionManager.SetCurrentServer(conn.Id);
                    var discovered = await QueryExecutor.GetSqlWatchInstanceNamesAsync();

                    if (discovered.Count > 0)
                    {
                        foreach (var inst in discovered)
                            _sqlWatchInstanceToConnectionId[inst] = conn.Id;
                        allInstances.AddRange(discovered);
                        _connectionsWithSqlWatch.Add(conn.Id);

                        System.Diagnostics.Debug.WriteLine(
                            $"[DynamicDashboard:{DashboardId}] '{conn.ServerNames}': SQLWATCH found ‚Äî {string.Join(", ", discovered)}");
                        continue; // skip configured names; use discovered names
                    }

                    System.Diagnostics.Debug.WriteLine(
                        $"[DynamicDashboard:{DashboardId}] '{conn.ServerNames}': HasSqlWatch=true but no instances found (not installed?)");
                }
                catch (Exception ex)
                {
                    System.Diagnostics.Debug.WriteLine(
                        $"[DynamicDashboard:{DashboardId}] Discovery failed for '{conn.ServerNames}': {ex.Message}");
                }
            }

            // HasSqlWatch=false OR SQLWATCH discovery returned nothing ‚Äî use configured names.
            allInstances.AddRange(conn.GetServerList());
        }

        Instances = allInstances.Distinct(StringComparer.OrdinalIgnoreCase).ToArray();

        // Keep SelectedInstance pointing at a valid entry.
        if (!Instances.Contains(SelectedInstance, StringComparer.OrdinalIgnoreCase))
            SelectedInstance = Instances.FirstOrDefault() ?? "";

        SetServerContext(SelectedInstance);

        System.Diagnostics.Debug.WriteLine(
            $"[DynamicDashboard:{DashboardId}] Discovery complete. Instances: [{string.Join(", ", Instances)}]. Selected: {SelectedInstance}");
    }

    private async Task LoadData(CancellationToken cancellationToken = default)
    {
        if (Dashboard == null)
        {
            ErrorMessage = $"Dashboard '{DashboardId}' not found in configuration.";
            IsLoading = false;
            return;
        }

        // Skip loading for SQLWATCH-dependent dashboards when SQLWATCH is not available.
        // The UI will show the "SQLWATCH not installed" banner instead.
        if (RequiresSqlWatch && !CurrentServerHasSqlWatch)
        {
            IsLoading = false;
            return;
        }

        // Log memory before load
        var process = System.Diagnostics.Process.GetCurrentProcess();
        var memBefore = process.WorkingSet64 / 1024.0 / 1024.0;
        System.Diagnostics.Debug.WriteLine($"[DynamicDashboard] Memory before load: {memBefore:F1} MB");

        IsLoading = true;
        ErrorMessage = null;
        _panelErrors.Clear();
        
        // Dispose old DataTables before replacing
        foreach (var dt in _gridResults.Values)
        {
            dt?.Dispose();
        }
        _gridResults.Clear();

        var filter = BuildFilter();
        await CachingExecutor.PrepareRefreshCycle(DashboardId, TimeRangeMinutes, SelectedInstance, TimezoneOffsetHours);

        var tsResults = new ConcurrentDictionary<string, List<TimeSeriesPoint>>();
        var statResults = new ConcurrentDictionary<string, StatValue>();
        var bgResults = new ConcurrentDictionary<string, List<StatValue>>();
        var gridResults = new ConcurrentDictionary<string, DataTable>();
        var checkResults = new ConcurrentDictionary<string, List<CheckStatus>>();

        var panelsToLoad = _enabledPanelsCache ?? Dashboard.Panels;

        var tasks = panelsToLoad.Select(async panel =>
            await QueryThrottle.ExecuteAsync(async () =>
            {
                await LoadPanelDataAsync(panel, filter, tsResults, statResults, bgResults, gridResults, checkResults, cancellationToken);
                return Task.CompletedTask;
            },
            isHeavy: panel.PanelType == "TimeSeries",
            cancellationToken));

        await Task.WhenAll(tasks);

        // Swap references after all tasks complete
        _timeSeriesResults = tsResults;
        _statResults = statResults;
        _barGaugeResults = bgResults;
        _gridResults = gridResults;
        _checkResults = checkResults;

        RefreshPanelCaches();

        // Log memory after load
        process = System.Diagnostics.Process.GetCurrentProcess();
        var memAfter = process.WorkingSet64 / 1024.0 / 1024.0;
        System.Diagnostics.Debug.WriteLine($"[DynamicDashboard] Memory after load: {memAfter:F1} MB (delta: {memAfter - memBefore:F1} MB)");

        // Force garbage collection to free memory from old data
        if (memAfter - memBefore > 50) // Only GC if memory increased by more than 50MB
        {
            System.Diagnostics.Debug.WriteLine("[DynamicDashboard] Forcing GC collection...");
            GC.Collect(2, GCCollectionMode.Optimized, false);
        }

        IsLoading = false;
        await InvokeAsync(StateHasChanged);
    }
    
    private async Task LoadPanelDataAsync(
    PanelDefinition panel,
    DashboardFilter filter,
    ConcurrentDictionary<string, List<TimeSeriesPoint>> tsResults,
    ConcurrentDictionary<string, StatValue> statResults,
    ConcurrentDictionary<string, List<StatValue>> bgResults,
    ConcurrentDictionary<string, DataTable> gridResults,
    ConcurrentDictionary<string, List<CheckStatus>> checkResults,
    CancellationToken cancellationToken)
    {
        try
        {
            switch (panel.PanelType)
            {
                case "TimeSeries":
                    var tsData = await CachingExecutor.ExecuteQueryAsync(panel.Id, filter, MapTimeSeriesPoint, null, cancellationToken);
                    tsResults[panel.Id] = tsData;
                    break;
                case "StatCard":
                case "DeltaStatCard":
                    var dt = await CachingExecutor.ExecuteQueryAsync(panel.Id, filter, null, cancellationToken);
                    if (dt.Rows.Count > 0)
                    {
                        var val = Convert.ToDouble(dt.Rows[0]["Value"]);
                        var color = panel.ColorThresholds?.Count > 0
                            ? panel.GetThresholdColor(val)
                            : ThresholdConfig.GetColor(panel.StatThresholdKey, val);
                        statResults[panel.Id] = new StatValue { Label = panel.Title, Value = val, Unit = panel.StatUnit, Color = color };
                    }
                    break;
                case "BarGauge":
                    var bgData = await CachingExecutor.ExecuteQueryAsync(panel.Id, filter, reader =>
                    {
                        var val = Convert.ToDouble(reader["Value"]);
                        var color = panel.ColorThresholds?.Count > 0
                            ? panel.GetThresholdColor(val)
                            : ThresholdConfig.GetColor(panel.BarGaugeThresholdKey ?? "", val);
                        return new StatValue { Label = reader["Label"]?.ToString() ?? "", Value = val, Unit = reader["Unit"]?.ToString() ?? "%", Instance = reader["Instance"]?.ToString() ?? "", Color = color };
                    }, null, cancellationToken);
                    bgResults[panel.Id] = bgData;
                    break;
                case "DataGrid":
                case "TextCard":
                    Dictionary<string, object>? gridParams = null;
                    if (panel.DataGridTopRows > 0)
                    {
                        var topRows = _panelTopRows.TryGetValue(panel.Id, out var tr) ? tr : panel.DataGridTopRows;
                        gridParams = new Dictionary<string, object> { ["@TopRows"] = topRows };
                    }
                    var gridData = await CachingExecutor.ExecuteQueryAsync(panel.Id, filter, gridParams, cancellationToken);
                    gridResults[panel.Id] = gridData;
                    break;
                case "CheckStatus":
                    var checkData = await CachingExecutor.ExecuteQueryAsync(panel.Id, filter, reader => new CheckStatus { Status = reader["Status"]?.ToString() ?? "OK", Count = reader["Count"] != DBNull.Value ? Convert.ToInt32(reader["Count"]) : 0 }, null, cancellationToken);
                    checkResults[panel.Id] = checkData;
                    break;

                case "SessionBubble":
                    // SessionBubble is real-time only ‚Äî rendered on the dedicated /sessions page.
                    // No data loading needed here; the DynamicPanel shows a link to /sessions.
                    break;
            }
        }
        catch (Exception ex)
        {
            _panelErrors[panel.Id] = $"Panel '{panel.Id}' error: {ex.Message}";
        }
    }


    private RenderFragment RenderChartOrGrid(PanelDefinition panel) => builder =>
    {
        builder.OpenComponent<DynamicPanel>(0);
        builder.AddAttribute(1, "Panel", panel);
        builder.AddAttribute(5, "TimezoneOffsetHours", TimezoneOffsetHours);

        if (panel.PanelType == "TimeSeries" && _timeSeriesResults.TryGetValue(panel.Id, out var tsData))
            builder.AddAttribute(2, "TimeSeriesData", tsData);
        else if (panel.PanelType == "DataGrid" && _gridResults.TryGetValue(panel.Id, out var gridData))
        {
            builder.AddAttribute(3, "GridData", gridData);
            if (panel.DataGridTopRows > 0)
            {
                var topRows = _panelTopRows.TryGetValue(panel.Id, out var t) ? t : panel.DataGridTopRows;
                builder.AddAttribute(6, "TopRowsValue", (int?)topRows);
                builder.AddAttribute(7, "OnTopRowsConfigChanged",
                    EventCallback.Factory.Create<int>(this, val => OnPanelTopRowsChanged(panel.Id, val)));
            }
        }
        else if (panel.PanelType == "TextCard" && _gridResults.TryGetValue(panel.Id, out var textData))
            builder.AddAttribute(4, "GridData", textData);

        builder.CloseComponent();
    };

    private async Task OnPanelTopRowsChanged(string panelId, int newTopRows)
    {
        _panelTopRows[panelId] = newTopRows;
        // Reload just the one panel that changed
        var panel = _enabledPanelsCache?.FirstOrDefault(p => p.Id == panelId);
        if (panel == null) return;
        var filter = BuildFilter();
        var topRows = newTopRows;
        var gridParams = new Dictionary<string, object> { ["@TopRows"] = topRows };
        try
        {
            var newData = await CachingExecutor.ExecuteQueryAsync(panelId, filter, gridParams);
            if (_gridResults.TryGetValue(panelId, out var old)) old?.Dispose();
            _gridResults[panelId] = newData;
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            _panelErrors[panelId] = $"Panel '{panelId}' error: {ex.Message}";
        }
    }

    private async Task OnManualRefresh()
    {
        await LoadData();
    }

    private async Task OnServerConnectionChanged()
    {
        await LoadData();
    }

    private async void OnAutoRefresh()
    {
        try
        {
            using var cts = new System.Threading.CancellationTokenSource();
            cts.CancelAfter(TimeSpan.FromSeconds(30));
            await InvokeAsync(async () => await LoadData(cts.Token));
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"[DynamicDashboard:{DashboardId}] AutoRefresh error: {ex}");
        }
    }

    private async void OnConfigChanged()
    {
        Dashboard = ConfigService.Config.Dashboards.FirstOrDefault(d => string.Equals(d.Id, DashboardId, StringComparison.OrdinalIgnoreCase));
        RefreshPanelCaches();
        await InvokeAsync(() => LoadData());
    }

    public void Dispose()
    {
        // Dispose DataTables to prevent memory leaks
        foreach (var dt in _gridResults.Values)
        {
            dt?.Dispose();
        }
        _gridResults.Clear();
        
        // Clear all data dictionaries to free memory
        _timeSeriesResults.Clear();
        _statResults.Clear();
        _barGaugeResults.Clear();
        _checkResults.Clear();
        _panelErrors.Clear();
        
        // Unsubscribe from events without stopping RefreshService (affects all dashboards)
        RefreshService.OnRefresh -= OnAutoRefresh;
        ConfigService.OnConfigChanged -= OnConfigChanged;
        InstanceSelector.OnInstanceChanged -= OnGlobalInstanceChanged;
        
        System.Diagnostics.Debug.WriteLine($"[DynamicDashboard] Disposed dashboard '{DashboardId}'. Memory freed.");
    }

    private static TimeSeriesPoint MapTimeSeriesPoint(IDataReader reader) => new()
    {
        Time = reader["Time"] as DateTime? ?? DateTime.MinValue,
        Series = reader["Series"]?.ToString() ?? "",
        Value = reader["Value"] != DBNull.Value ? Convert.ToDouble(reader["Value"]) : 0.0
    };

}

